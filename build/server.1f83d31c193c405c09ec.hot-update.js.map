{"version":3,"file":"server.1f83d31c193c405c09ec.hot-update.js","sources":["webpack:///./src/routes.js"],"sourcesContent":["import { ethers } from 'ethers'\r\nimport React from 'react';\r\nimport { StaticRouter } from 'react-router-dom';\r\nimport { renderToString } from 'react-dom/server';\r\nimport fetch from 'cross-fetch';\r\nimport sizeof from 'object-sizeof'\r\n\r\nimport App from './App';\r\nimport { ApolloClient, InMemoryCache, gql, HttpLink } from '@apollo/client'\r\nimport { getLogger } from './helpers'\r\nimport { addresses, OPTIMISM } from './addresses'\r\nimport { queryEarnData, getStatsFromSubgraph } from './dataProvider'\r\n\r\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\r\n\r\nconst assets = require(process.env.RAZZLE_ASSETS_MANIFEST);\r\n\r\nconst cssLinksFromAssets = (assets, entrypoint) => {\r\n  return assets[entrypoint] ? assets[entrypoint].css ?\r\n  assets[entrypoint].css.map(asset=>\r\n    `<link rel=\"stylesheet\" href=\"${asset}\">`\r\n  ).join('') : '' : '';\r\n};\r\n\r\nconst jsScriptTagsFromAssets = (assets, entrypoint, extra = '') => {\r\n  return assets[entrypoint] ? assets[entrypoint].js ?\r\n  assets[entrypoint].js.map(asset=>\r\n    `<script src=\"${asset}\"${extra}></script>`\r\n  ).join('') : '' : '';\r\n};\r\n\r\nconst { formatUnits} = ethers.utils\r\n\r\nconst logger = getLogger('routes')\r\n\r\nconst apolloOptions = {\r\n  query: {\r\n    fetchPolicy: 'no-cache'\r\n  },\r\n  watchQuery: {\r\n    fetchPolicy: 'no-cache'\r\n  }\r\n}\r\n\r\nconst optimismGraphClient = new ApolloClient({\r\n  link: new HttpLink({ uri: process.env.RAZZLE_SUBGRAPH_URL, fetch }),\r\n  cache: new InMemoryCache(),\r\n  defaultOptions: apolloOptions\r\n})\r\n\r\nconst cachedPrices = {\r\n  sorted: {\r\n    [OPTIMISM]: {},\r\n  },\r\n  byKey: {\r\n    [OPTIMISM]: {},\r\n  }\r\n}\r\nfunction putPricesIntoCache(prices, chainId, entitiesKey) {\r\n  if (!prices || !chainId || !entitiesKey) {\r\n    throw new Error('Invalid arguments')\r\n  }\r\n  let ret = true\r\n  const precision = entitiesKey === \"chainlinkPrices\" ? 1e8 : 1e30\r\n  const changedTokens = new Set([])\r\n  const byKeyNs = cachedPrices.byKey\r\n  byKeyNs[chainId][entitiesKey] = byKeyNs[chainId][entitiesKey] || {}\r\n  for (const price of prices) {\r\n    const token = price.token.toLowerCase()\r\n    const timestamp = price.timestamp\r\n    byKeyNs[chainId][entitiesKey][token] = byKeyNs[chainId][entitiesKey][token] || {}\r\n    byKeyNs[chainId][entitiesKey][token][timestamp] = Number(price.value) / precision\r\n    changedTokens.add(token)\r\n  }\r\n\r\n  const sortedNs = cachedPrices.sorted\r\n  sortedNs[chainId][entitiesKey] = sortedNs[chainId][entitiesKey] || {}\r\n  for (const token of changedTokens) {\r\n    sortedNs[chainId][entitiesKey][token] = Object.entries(byKeyNs[chainId][entitiesKey][token])\r\n      .map(([timestamp, price]) => [Number(timestamp), price])\r\n      .sort((a, b) => a[0] - b[0])\r\n  }\r\n\r\n  if (!IS_PRODUCTION) {\r\n    console.time('sizeof call')\r\n    const size = sizeof(cachedPrices) / 1024 / 1024\r\n    console.timeEnd('sizeof call')\r\n    let pricesCount = 0\r\n    for (const chainId of Object.keys(cachedPrices.sorted)) {\r\n      for (const entitiesKey of Object.keys(cachedPrices.sorted[chainId])) {\r\n        for (const prices of Object.values(cachedPrices.sorted[chainId][entitiesKey])) {\r\n          pricesCount += prices.length\r\n        }\r\n      }\r\n    }\r\n    logger.debug('Estimated price cache size: %s MB, prices count: %s', size, pricesCount)\r\n  }\r\n\r\n  return ret\r\n}\r\n\r\nclass TtlCache {\r\n  constructor(ttl = 60, maxKeys) {\r\n    this._cache = {}\r\n    this._ttl = ttl\r\n    this._maxKeys = maxKeys\r\n    this._logger = getLogger('routes.TtlCache')\r\n  }\r\n\r\n  get(key) {\r\n    this._logger.debug('get key %s', key)\r\n    return this._cache[key]\r\n  }\r\n\r\n  set(key, value) {\r\n    this._cache[key] = value\r\n\r\n    const keys = Object.keys(this._cache)\r\n    if (this._maxKeys && keys.length >= this._maxKeys) {\r\n      for (let i = 0; i <= keys.length - this._maxKeys; i++) {\r\n        this._logger.debug('delete key %s (max keys)', key)\r\n        delete this._cache[keys[i]]\r\n      }\r\n    }\r\n\r\n    setTimeout(() => {\r\n      this._logger.debug('delete key %s (ttl)', key)\r\n      delete this._cache[key]\r\n    }, this._ttl * 1000)\r\n\r\n    if (!IS_PRODUCTION) {\r\n      console.time('sizeof call')\r\n      const size = sizeof(this._cache) / 1024 / 1024\r\n      console.timeEnd('sizeof call')\r\n      this._logger.debug('TtlCache cache size %s MB', size)\r\n    }\r\n  }\r\n}\r\nconst ttlCache = new TtlCache(60, 100)\r\n\r\nfunction sleep(ms) {\r\n  return new Promise(resolve => {\r\n    setTimeout(resolve, ms)\r\n  })\r\n}\r\n\r\nasync function precacheOldPrices(chainId, entitiesKey) {\r\n  logger.info('precache old prices into memory for %s...', chainId)\r\n\r\n  const baseRetryTimeout = 10000\r\n  let oldestTimestamp = parseInt(Date.now() / 1000)\r\n  let i = 0\r\n  let retryTimeout = baseRetryTimeout\r\n  let failCount = 0\r\n  while (i < 100) {\r\n    try {\r\n      const prices = await loadPrices({ before: oldestTimestamp, chainId, entitiesKey })\r\n      if (prices.length === 0) {\r\n        logger.info('All old prices loaded for chain: %s %s', chainId, entitiesKey)\r\n        break\r\n      }\r\n\r\n      if (!putPricesIntoCache(prices, chainId, entitiesKey)) {\r\n        logger.info('putPricesIntoCache returned false for chain: %s %s. stop', chainId, entitiesKey)\r\n        break\r\n      }\r\n      oldestTimestamp = prices[prices.length - 1].timestamp - 1\r\n      failCount = 0\r\n      retryTimeout = baseRetryTimeout\r\n    } catch (ex) {\r\n      failCount++\r\n      logger.warn('Old prices load failed')\r\n      logger.error(ex)\r\n      if (failCount > 10) {\r\n        logger.warn('too many load failures for chainId: %s %s. retry in %s seconds',\r\n          chainId, entitiesKey, retryTimeout / 1000)\r\n        await sleep(retryTimeout)\r\n        retryTimeout *= 2\r\n      }\r\n      await sleep(500)\r\n    }\r\n    i++\r\n  }\r\n}\r\nif (!process.env.DISABLE_PRICES) {\r\n  precacheOldPrices(OPTIMISM, \"chainlinkPrices\")\r\n  precacheOldPrices(OPTIMISM, \"fastPrices\")\r\n}\r\n\r\n\r\nlet newestPriceTimestamp = parseInt(Date.now() / 1000) - 60 * 5\r\nasync function precacheNewPrices(chainId, entitiesKey) {\r\n  logger.info('Precache new prices into memory chainId: %s %s...', chainId, entitiesKey)\r\n\r\n  try {\r\n    const after = newestPriceTimestamp - 60 * 15 // 15 minutes before last update.\r\n    const prices = await loadPrices({ after, chainId, entitiesKey })\r\n    if (prices.length > 0) {\r\n      logger.info('Loaded %s prices since %s chainId: %s %s',\r\n        prices.length,\r\n        toReadable(after),\r\n        chainId,\r\n        entitiesKey\r\n      )\r\n      if (putPricesIntoCache(prices, chainId, entitiesKey)) {\r\n        newestPriceTimestamp = prices[0].timestamp\r\n      } else {\r\n        logger.warn('Prices were not saved')\r\n      }\r\n    }\r\n  } catch (ex) {\r\n    logger.warn('New prices load failed chainId: %s %s', chainId, entitiesKey)\r\n    logger.error(ex)\r\n  }\r\n\r\n  setTimeout(precacheNewPrices, 1000 * 60 * 1, chainId, entitiesKey)\r\n}\r\nif (!process.env.DISABLE_PRICES) {\r\n  precacheNewPrices(OPTIMISM, \"chainlinkPrices\")\r\n  precacheNewPrices(OPTIMISM, \"fastPrices\")\r\n}\r\n\r\nasync function loadPrices({ before, after, chainId, entitiesKey } = {}) {\r\n  if (!chainId) {\r\n    throw new Error('loadPrices requires chainId')\r\n  }\r\n  if (!entitiesKey) {\r\n    throw new Error('loadPrices requires entitiesKey')\r\n  }\r\n  if (!before) {\r\n    before = parseInt(Date.now() / 1000) + 86400 * 365\r\n  }\r\n  if (!after) {\r\n    after = 0\r\n  }\r\n  logger.info('loadPrices %s chainId: %s before: %s, after: %s',\r\n    entitiesKey,\r\n    chainId,\r\n    toReadable(before),\r\n    after && toReadable(after)\r\n  )\r\n\r\n  const fragment = (skip) => {\r\n     return `${entitiesKey}(\r\n      first: 1000\r\n      skip: ${skip}\r\n      orderBy: timestamp\r\n      orderDirection: desc\r\n      where: {\r\n        timestamp_lte: ${before}\r\n        timestamp_gte: ${after}\r\n        period: any\r\n      }\r\n    ) { value, timestamp, token }\\n`\r\n  }\r\n  const queryString = `{\r\n    p0: ${fragment(0)}\r\n    p1: ${fragment(1000)}\r\n    p2: ${fragment(2000)}\r\n    p3: ${fragment(3000)}\r\n    p4: ${fragment(4000)}\r\n    p5: ${fragment(5000)}\r\n  }`\r\n  const query = gql(queryString)\r\n\r\n  const graphClient = optimismGraphClient;\r\n  const { data } = await graphClient.query({query})\r\n  const prices = [\r\n    ...data.p0,\r\n    ...data.p1,\r\n    ...data.p2,\r\n    ...data.p3,\r\n    ...data.p4,\r\n    ...data.p5\r\n  ]\r\n\r\n  if (prices.length) {\r\n    logger.debug('Loaded %s prices (%s â€“ %s) for chain %s %s',\r\n      prices.length,\r\n      toReadable(prices[prices.length - 1].timestamp),\r\n      toReadable(prices[0].timestamp),\r\n      chainId,\r\n      entitiesKey,\r\n    )\r\n  }\r\n\r\n  return prices\r\n}\r\n\r\nfunction toReadable(ts) {\r\n  return (new Date(ts * 1000).toISOString()).replace('T', ' ').replace('.000Z', '')\r\n}\r\n\r\nfunction getPriceRange(sortedPrices, from, to, inbound = false) {\r\n  const indexFrom = binSearchPrice(sortedPrices, from, inbound)\r\n  const indexTo = binSearchPrice(sortedPrices, to, !inbound) + 1\r\n\r\n  return [\r\n    sortedPrices.slice(indexFrom, indexTo),\r\n    sortedPrices[0][0]\r\n  ]\r\n}\r\n\r\nfunction binSearchPrice(prices, timestamp, gt = true) {\r\n  let left = 0\r\n  let right = prices.length - 1\r\n  let mid\r\n  while (left + 1 < right) {\r\n    mid = Math.floor((left + right) / 2)\r\n    if (prices[mid][0] < timestamp) {\r\n      left = mid\r\n    } else {\r\n      right = mid\r\n    }\r\n  }\r\n  const ret = gt ? right : left\r\n  return ret\r\n}\r\n\r\nfunction getPrices(from, to, preferableChainId = OPTIMISM, preferableSource = \"chainlink\", symbol) {\r\n  const start = Date.now()\r\n\r\n  if (preferableSource !== \"chainlink\" && preferableSource !== \"fast\") {\r\n    throw createHttpError(400, `Invalid preferableSource ${preferableSource}. Valid options are: chainlink, fast`)\r\n  }\r\n\r\n  const validSymbols = new Set(['OP', 'BTC', 'ETH'])\r\n  if (!validSymbols.has(symbol)) {\r\n    throw createHttpError(400, `Invalid symbol ${symbol}`)\r\n  }\r\n  preferableChainId = Number(preferableChainId)\r\n  const validSources = new Set([OPTIMISM])\r\n  if (!validSources.has(preferableChainId)) {\r\n    throw createHttpError(400, `Invalid preferableChainId ${preferableChainId}. Valid options are ${OPTIMISM}`)\r\n  }\r\n\r\n  const tokenAddress = addresses[preferableChainId][symbol]?.toLowerCase()\r\n  if (!tokenAddress || !cachedPrices.byKey[preferableChainId].chainlinkPrices\r\n    || !cachedPrices.byKey[preferableChainId].chainlinkPrices[tokenAddress]\r\n  ) {\r\n    return []\r\n  }\r\n\r\n  const cacheKey = `${from}:${to}:${preferableChainId}:${preferableSource}:${symbol}`\r\n  const fromCache = ttlCache.get(cacheKey)\r\n  if (fromCache) {\r\n    logger.debug('from cache')\r\n    return fromCache\r\n  }\r\n\r\n  const entitiesKey = preferableSource === \"chainlink\" ? \"chainlinkPrices\" : \"fastPrices\"\r\n\r\n  const sortedPrices = (\r\n    cachedPrices.sorted[preferableChainId]\r\n    && cachedPrices.sorted[preferableChainId][entitiesKey]\r\n    && cachedPrices.sorted[preferableChainId][entitiesKey][tokenAddress]\r\n  ) || []\r\n\r\n  let [prices, firstTimestamp] = getPriceRange(sortedPrices, from, to)\r\n\r\n  if (preferableSource === \"fast\" && firstTimestamp > from) {\r\n    // there is no enough fast price data. upfill it with chainlink prices\r\n    const otherSortedPrices = (\r\n      cachedPrices.sorted[preferableChainId]\r\n      && cachedPrices.sorted[preferableChainId].chainlinkPrices\r\n      && cachedPrices.sorted[preferableChainId].chainlinkPrices[tokenAddress]\r\n    ) || []\r\n    const [chainlinkPrices] = getPriceRange(otherSortedPrices, from, firstTimestamp, true)\r\n\r\n    prices = [...chainlinkPrices, ...prices]\r\n  }\r\n\r\n  ttlCache.set(cacheKey, prices)\r\n\r\n  logger.debug('getPrices took %sms cacheKey %s', Date.now() - start, cacheKey)\r\n\r\n  return prices\r\n}\r\n\r\nconst periodsMap = {\r\n  '5m': 60 * 5,\r\n  '15m': 60 * 15,\r\n  '1h': 60 * 60,\r\n  '4h': 60 * 60 * 4,\r\n  '1d': 60 * 60 * 24,\r\n  '1w': 60 * 60 * 24 * 7\r\n}\r\n\r\nfunction getCandles(prices, period) {\r\n  const periodTime = periodsMap[period]\r\n\r\n  if (prices.length < 2) {\r\n    return []\r\n  }\r\n\r\n  const candles = []\r\n  const first = prices[0]\r\n  let prevTsGroup = Math.floor(first[0] / periodTime) * periodTime\r\n  let prevPrice = first[1]\r\n  let prevTs = first[0]\r\n  let o = prevPrice\r\n  let h = prevPrice\r\n  let l = prevPrice\r\n  let c = prevPrice\r\n  for (let i = 1; i < prices.length; i++) {\r\n    const [ts, price] = prices[i]\r\n    const tsGroup = ts - (ts % periodTime)\r\n\r\n    if (prevTs > ts) {\r\n      logger.warn(`Invalid order prevTs: ${prevTs} (${toReadable(prevTs)}) ts: ${ts} (${toReadable(ts)})`)\r\n      continue\r\n    }\r\n\r\n    if (prevTsGroup !== tsGroup) {\r\n      candles.push({ t: prevTsGroup, o, h, l, c })\r\n      o = c\r\n      h = o > c ? o : c\r\n      l = o < c ? o : c\r\n    }\r\n    c = price\r\n    h = h > price ? h : price\r\n    l = l < price ? l : price\r\n    prevTsGroup = tsGroup\r\n    prevTs = ts\r\n  }\r\n\r\n  return candles\r\n}\r\n\r\nfunction getFromAndTo(req) {\r\n  const granularity = 60 // seconds\r\n  let from = Number(req.query.from) || Math.round(Date.now() / 1000) - 86400 * 90\r\n  from = Math.floor(from / granularity) * granularity\r\n  let to = Number(req.query.to) || Math.round(Date.now() / 1000)\r\n  to = Math.ceil(to / granularity) * granularity\r\n\r\n  return [from, to]\r\n}\r\n\r\nfunction createHttpError(code, message) {\r\n  const error = new Error(message)\r\n  error.code = code\r\n  return error\r\n}\r\n\r\nexport default function routes(app) {\r\n\r\n  app.get('/api/total_volumes', async (req, res, next) => {\r\n    const queryString = `\r\n    {\r\n      volumeStats (where : {period:\"total\"}){\r\n        id\r\n        swap\r\n        mint\r\n        margin\r\n        burn\r\n        liquidation\r\n        period\r\n      }\r\n    }\r\n    `\r\n    const query = gql(queryString);\r\n\r\n    const graphClient = optimismGraphClient;\r\n    const { data } = await graphClient.query({query})\r\n    \r\n    try {\r\n      const stats = data.volumeStats[0]\r\n      const statsResponse = {\r\n        swap: parseInt(stats.swap) / 1e30,\r\n        mint: parseInt(stats.mint) / 1e30,\r\n        burn: parseInt(stats.burn) / 1e30,\r\n        margin: parseInt(stats.margin) / 1e30,\r\n        liquidation: parseInt(stats.liquidation) / 1e30\r\n      };\r\n\r\n      statsResponse.total = statsResponse.swap + statsResponse.mint + statsResponse.burn + statsResponse.margin + statsResponse.liquidation;\r\n      res.set('Cache-Control', 'max-age=60')\r\n      res.send(statsResponse)\r\n    } catch (ex) {\r\n      logger.error(ex)\r\n      next(createHttpError(500, ex.message))\r\n      return\r\n    }\r\n  })\r\n\r\n  app.get('/api/stats', async (req, res, next) => {\r\n\r\n    try {\r\n      const stats = await getStatsFromSubgraph(optimismGraphClient);\r\n      res.set('Cache-Control', 'max-age=60')\r\n      res.send(stats)\r\n    } catch (ex) {\r\n      logger.error(ex)\r\n      next(createHttpError(500, ex.message))\r\n      return\r\n    }\r\n  })\r\n\r\n  app.get('/api/total_volumes_delta', async (req, res, next) => {\r\n    const queryString = `\r\n    {\r\n      volumeStats (first:1 orderBy: timestamp orderDirection: desc where : {period:\"daily\"}){\r\n        id\r\n        swap\r\n        mint\r\n        margin\r\n        burn\r\n        liquidation\r\n        period\r\n      }\r\n    }\r\n    `\r\n    const query = gql(queryString);\r\n\r\n    const graphClient = optimismGraphClient;\r\n    const { data } = await graphClient.query({query})\r\n    \r\n    try {\r\n      const stats = data.volumeStats[0]\r\n      const statsResponse = {\r\n        swap: parseInt(stats.swap) / 1e30,\r\n        mint: parseInt(stats.mint) / 1e30,\r\n        burn: parseInt(stats.burn) / 1e30,\r\n        margin: parseInt(stats.margin) / 1e30,\r\n        liquidation: parseInt(stats.liquidation) / 1e30\r\n      };\r\n\r\n      statsResponse.total = statsResponse.swap + statsResponse.mint + statsResponse.burn + statsResponse.margin + statsResponse.liquidation;\r\n      res.set('Cache-Control', 'max-age=60')\r\n      res.send(statsResponse)\r\n    } catch (ex) {\r\n      logger.error(ex)\r\n      next(createHttpError(500, ex.message))\r\n      return\r\n    }\r\n  })\r\n\r\n  app.get('/api/earn/:account', async (req, res, next) => {\r\n    const chainName = req.query.chain || 'optimism'\r\n    const validChainNames = new Set(['optimism'])\r\n    if (!validChainNames.has(chainName)) {\r\n      next(createHttpError(400, `Valid chains are: ${Array.from(validChainNames)}`))\r\n      return\r\n    }\r\n    try {\r\n      const earnData = await queryEarnData(chainName, req.params.account)\r\n      res.send(earnData)\r\n    } catch (ex) {\r\n      logger.error(ex)\r\n      next(createHttpError(500, ex.message))\r\n      return\r\n    }\r\n  })\r\n\r\n  app.get('/api/skull-supply', async (req, res) => {\r\n    const apiResponse = await fetch('https://stats.masonjar.finance/api/total_supply')\r\n    const data = (await apiResponse.text()).toString()\r\n    res.set('Content-Type', 'text/plain')\r\n    res.send(formatUnits(data))\r\n  })\r\n\r\n  app.get('/api/chart/:symbol', async (req, res, next) => {\r\n    const [from, to] = getFromAndTo(req)\r\n\r\n    let prices\r\n    try {\r\n      prices = getPrices(from, to, req.query.preferableChainId, req.query.preferableSource, req.params.symbol)\r\n    } catch (ex) {\r\n      next(ex)\r\n      return\r\n    }\r\n\r\n    res.set('Cache-Control', 'max-age=60')\r\n    res.send(prices)\r\n  })\r\n\r\n  app.get('/api/candles/:symbol', async (req, res, next) => {\r\n    const [from, to] = getFromAndTo(req)\r\n\r\n    let prices\r\n    try {\r\n      prices = getPrices(from, to, req.query.preferableChainId, req.query.preferableSource, req.params.symbol)\r\n    } catch (ex) {\r\n      next(ex)\r\n      return\r\n    }\r\n\r\n    const period = req.query.period?.toLowerCase()\r\n    if (!period || !periodsMap[period]) {\r\n      next(createHttpError(400, `Invalid period. Valid periods are ${Object.keys(periodsMap)}`))\r\n      return\r\n    }\r\n\r\n    const candles = getCandles(prices, period)\r\n    let updatedAt\r\n    if (prices.length) {\r\n      updatedAt = prices[prices.length - 1][0]\r\n    }\r\n\r\n    res.set('Cache-Control', 'max-age=60')\r\n    res.send({\r\n      prices: candles,\r\n      period,\r\n      updatedAt\r\n    })\r\n  })\r\n\r\n  const cssAssetsTag = cssLinksFromAssets(assets, 'client')\r\n  const jsAssetsTag = jsScriptTagsFromAssets(assets, 'client', ' defer crossorigin')\r\n\r\n  app.get('/*', (req, res, next) => {\r\n    if (res.headersSent) {\r\n      next()\r\n      return\r\n    }\r\n\r\n    const context = {};\r\n    const markup = renderToString(\r\n      <StaticRouter context={context} location={req.url}>\r\n        <App />\r\n      </StaticRouter>\r\n    );\r\n    res.set('Content-Type', 'text/html')\r\n\r\n    res.status(200).send(\r\n      `<!doctype html>\r\n          <html lang=\"\">\r\n          <head>\r\n              <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\r\n              <meta charset=\"utf-8\" />\r\n              <title>Mason Jar Statistics</title>\r\n              <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n              <link rel=\"icon\" type=\"image/png\" href=\"/favicon.png\" />\r\n              ${cssAssetsTag}\r\n          </head>\r\n          <body>\r\n              <div id=\"root\">${markup}</div>\r\n              ${jsAssetsTag}\r\n          </body>\r\n      </html>`\r\n    );\r\n    next()\r\n  });\r\n\r\n  app.use('/api', function (err, req, res, next) {\r\n    res.set('Content-Type', 'text/plain')\r\n    const statusCode = Number(err.code) || 500\r\n    let response = ''\r\n    if (IS_PRODUCTION) {\r\n      if (err.code === 400) {\r\n        response = err.message\r\n      }\r\n    } else {\r\n      response = err.stack\r\n    }\r\n    res.status(statusCode)\r\n    res.send(response)\r\n  })\r\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAIA;AAEA;AACA;AAIA;AAEA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AASA;AACA;AAOA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAMA;AAEA;AACA;AACA;AAKA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}